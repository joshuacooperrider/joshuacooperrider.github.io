---
layout: essay
type: essay
title: "Beyond Code: What Software Engineering Taught Me About Building Well"
date: 2025-05-14
published: true
labels:
  - Software Engineering
  - Learning
---
<img width="400px" class="rounded float-start pe-4" src="../img/mountain.png">

### Introduction

When signing up for a software engineering class, I expected to learn how to develop applications and websites. Oh-boy, was I underestimating what that entailed. Sure, we did plenty of that — using tools and technologies like Bootstrap, Next.js, HTML, and TypeScript — but we also dove into ideas that extended far beyond just writing code. This course taught me how to engineer software, and more importantly, how to collaborate, manage complexity, and write systems that can grow and last. In the process, I learned that while tools come and go, the principles of software engineering stay with you.

### Coding Standards

What does your morning routine look like? Personally, I like to throw a couple of eggs on the stove (low heat, of course), start my coffee machine, grab my toothbrush, and jump in the shower. While taking care of my hygiene, my food and coffee are slowly getting ready so that when I’m out, I can throw on my work clothes, grab breakfast, and go.

I’m sure your routine looks different than mine in at least a few ways. But now imagine if I said, “Okay, Joshua just finished putting eggs on the stove. I need you to pick up from there and get to work on time.” Maybe for you, putting eggs on the stove is the final step before heading out. So you grab your eggs and leave—naked, un-caffeinated, and un-clean.

That’s where standards come in. When working with teams — or even just picking up old code you wrote months ago — having consistent, readable coding standards makes life significantly easier. Coding standards enforce uniformity in structure, formatting, and documentation. It's not just about where to place your brackets — it’s about writing code so clearly and predictably that someone else can seamlessly jump in, understand it, and build on it. Standards remove guesswork, reduce bugs, and make code maintainable. Just like a good morning routine, they bring order to chaos.

### Configuration Management

Now imagine you’re working on a group project, and everyone is writing different parts of the codebase. You add a new feature, someone else fixes a bug, and another teammate reorganizes some files. Without a system in place, this would be absolute mayhem — overwritten code, merge nightmares, and mystery bugs introduced with no explanation. That’s where configuration management comes in.

Configuration management is the practice of keeping track of and controlling changes to software. In practical terms, this usually means using tools like Git and GitHub. But it’s more than just version control. It's about being able to trace who made which change, why they made it, and how it fits into the bigger picture. It allows teams to collaborate without stepping on each other’s toes.

This isn't just useful for web development — it's essential in almost every field involving software. Aerospace engineers need to make sure a change in one module of a flight system doesn’t accidentally break another. Medical software developers must document every change in case it affects patient outcomes. Researchers must ensure their experiments can be reproduced exactly, which means their codebase needs to reflect a precise state at a specific point in time. Configuration management makes all of this possible.

### Design Patterns

Before this class, if you had asked me how I structured my code, I probably would have said something like “logically” or “however it makes sense at the time.” But learning about design patterns helped me realize that there are established, time-tested ways of solving common problems in software architecture — ways that make code more flexible, testable, and easy to understand.

A design pattern is a general, reusable solution to a recurring problem in software design. For example, the Singleton pattern restricts a class so only one instance of it exists, which is useful for things like database connections. The Observer pattern lets different parts of a system react to changes in another — great for real-time interfaces or event-driven systems.

Learning about design patterns gave me vocabulary. Instead of saying, “I wrote a class that notifies other classes when it changes,” I can now say, “I implemented the Observer pattern.” That clarity is powerful in team settings and code reviews. Design patterns also scale. Whether I’m building a mobile app, a game engine, or an operating system, the principles still apply. They offer structure without forcing rigid rules — a sort of architectural scaffolding that makes projects easier to grow without falling apart.

## Conclusion

At the beginning of this course, I thought software engineering was just about writing code that works. I now realize it’s about writing code that lasts. Coding standards ensure consistency. Configuration management ensures reliability. Design patterns ensure scalability. Together, they transform individual efforts into collaborative achievements.

Whether I’m building a portfolio website, contributing to open source, or developing an application years from now, I’ll carry these lessons with me. This course wasn’t just about how to write code — it was about how to think like an engineer. And that mindset, more than any specific tool or language, is what will shape my future in software development.
